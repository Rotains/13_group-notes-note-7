포인터가 뭐야?
포인터란 C 언어의 가장 대표적인 특징 중 하나로, 일반 변수의 메모리 내 주소 번지를 가진 자료형이야.
포인터를 사용하면 변수명을 통하지 않고도 사용하고자 하는 대상에 직접 접근 할 수 있어서 프로그램이 간결해지고 효율적으로 제어돼!

또한 포인터 자료형으로 사용되는 연산자에는 주소 연산자와 간접 연산자가 있어. 
주소 연산자 &는 일반 변수명에 사용하고 해당 변수의 메모리 주소를 가르키고, 간접 연산자 *는 포인터 변수명에 사용하고 주소가 저장되어 있는 메모리 위치를 가리키는 차이 기억해!

#include <stdio.h>

void Swap(int a, int b);
int main(void)
{
	int x = 10, y = 5;
	printf("Swap() 함수 실행 전\n");
	printf("x = %d, y= %d이다.\n\n", x, y);

	Swap(x, y);
	printf("Swap() 함수 실행 후 \n");
	printf("x = %d, y = %d이다.\n", x, y);

	return 0;
}
void Swap(int a, int b);
{
	int temp;
	temp = a;
	a = b;
	b = temp;
}
함수 실행 전 x = 10, y = 5
함수 실행 후 x = 10, y = 5

결과 값이 바뀌지 않고 그대로 출력되었는데, 왜 그렇게 된 걸까?
main() 함수에서 Swap()함수를 호출할 때 인자로 전달된 변수 x, y는 그 자체 x, y인가?
아니 x,y는 값이야. x와 y값을 바꾸려면 x와 y 자체가 전달이 되어야 해!
Swap() 함수를 호출할 당시에 변수 x, y는 main() 함수에서 선언한 지역변수이기 때문에 메모리에 살아있게 되는거야!
그래서 우리는 두 수를 바꾸기 위해 x하고 y의 주소를 Swap() 함수에 넘겨주면 Swap() 함수에서 처리된 결과가 x, y값에 반영이 되는 거지!

그러면 주소값을 어떻게 전달해야해?
우리는 포인터를 함수의 인자로 사용해서 주소 값을 전달할 수 있어 그러면 변수 자체가 함수에 전달 돼. 그러면 함수를 통해서 두 수의 값이 바뀌는 거지!

#include <stdio.h>

void Swap(int* a, int* b);
int main(void)
{
	int x = 10, y = 5;
	printf("Swap() 함수 실행 전\n");
	printf("x = %d, y= %d이다.\n\n", x, y);

	Swap(x, y);
	printf("Swap() 함수 실행 후 \n");
	printf("x = %d, y = %d이다.\n", x, y);

	return 0;
}
void Swap(int* a, int* b);
{
	int temp;
	temp = *a;
	*a = *b;
	*b = temp;
}
함수 실행 전 x = 10, y = 5
함수 실행 후 x = 5, y = 10

포인터를 사용하니까 두 수의 값이 바뀌구나!!
포인터를 이용하면 포인터가 가리키는 곳의 값도 바뀌어지고 연산도 할 수 있으니까 상당히 편하구나!

그러면 포인터 변수의 크기도 알아야지! 
여기서 팁은 포인터 변수는 정수형이든 문자형이든 무조건 4바이트를 차지한다는 것!

포인터 변수를 정의하는 * 기호의 위치는 무조건 데이터형에 붙어야 해?
여기서 팁은 * 기호는 데이터형에 붙이든 변수에 붙이든 관계가 없어 편한대로 하면 돼!

인자 전달 방법이 뭐야?
함수에 사용될 데이터를 보내는 방법을 말해!
인자 전달 방법에는 데이터 값을 복사해서 보내는 방법과 데이터의 주소를 전달하는 방법이 있어!

인자를 값으로 전달(call by value) // 데이터 값을 보내는 방법 >> 지금까지 포인터를 사용하지 않고 작성했던 함수는 모두 이 방법을 사용한 것이다!
인자를 주소로 전달(call by reference) // 데이터의 주소를 전달하는 방법 >> 포인터의 유용성 부분에서 다루었던 Swap() 함수가 여기에 해당되는 거지! 인자를 주소로 전달하면 여러 가지로 유용해져!
인자를 주소로 전달하는 방법을 다른 말로는 참조 호출 또는 주소에 의한 매개변수 호출이라고도 하니 알아두자!

포인터와 배열에 있어서 주의해야할 점이 있어!
*p+1은 포인터 변수 p가 가리키는 곳의 값인 a[0]에 1을 더한 값을 의미해!
*p는 10이면 여기에 1을 더한 값인 11이 돼!
만약에 a의 두 번째 원소 값을 구하려고 하는 거면 *(p+1)이 배열 a의 두 번째 원소 값을 의미해!

#include <stdio.h>

int main(void)
{
int a[] = {10, 20, 30, 40, 50};
int *p = a;
int i;

printf("배열명 a를 이용한 주소 표현\n");
for(i = 0; i < 5; i+ +)
printf("a[%d]의 주소 %p\n",i, a +i);

printf("\n포인터 p를 이용한 배열 주소 표현\n");
for(i = 0; i < 5; i+ +)
printf("a[%d]의 주소 %p\n", i, p +i);

printf("\n 포인터 p를 이용한 배열 값 표현\n");
for(i = 0; i < 5; i+ +)
printf("a[%d] = %d\n",i, *(p +i));

return 0;
}

이로서 우린 배열과 포인터 관계를 통해 알 수 있는 게 있었어!
첫번째로는 배열명을 이용하여 a의 주소를 나타낸 것과 포인터 변수 p를 이용하여 a의 주소를 나타낸 것이 동일해!
두번째로는 포인터 변수 p를 이용하여 배열의 값을 나타낼 수 있어!

증강 연산자 적용
포인터 변수는 변수이므로 증감 연산자를 사용할 수 있는데 배열명은 증감 연산자를 사용할 수 없다.
배열명에 증감 연산자를 사용하는 것은 상수에 증감 연산자를 사용하는 것과 같다고 보면 된다!
포인터에 증감 연산자를 사용하면 포인터의 위치가 증감 연산자에 따라 변해!
따라서 증감 연산자의 사용에 따라 *p값이 바뀌는 거지!
 
배열의 합을 구하는 함수의 예

#include <stdio.h>

int SumArray(int* pA, int Size);
int main(void)
{
	int a[] = { 10,5,15,25,7 };
	int Sum;
	Sum = SumArray(a, 5);
	printf("배열의 합 : %d \n", Sum);

	return 0;
}

int SumArray(int* pA, int Size)
{
	int result = 0, i;
	for (i = 0; i < Size; i++)
		result += pA[i];

	return result;
}
#endif

배열의 합을 구하는 함수에서 첫 번째 인자로 배열을 사용했어! 이 경우에 배열 a의 값이 전달된다는 것이 단점이야! 배열 전체의 값이 전달되기 때문에 메모리의 이동량이 많아져!
하지만 우리는 포인터를 이용하였기 때문에 주소로 전달할 수 있어 주소를 표시하는 4바이트 크기의 포인터 변수만 메모리로 이동시킨거지!
